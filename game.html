<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Prototype: Shader Masking</title>
    <style>
        html, body { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; font-family: sans-serif; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            pointer-events: none;
            border-radius: 8px;
            max-width: 300px;
        }
        #score-box {
            margin-top: 10px;
            font-size: 1.2em;
            font-weight: bold;
            color: #0096FF;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }
        #fps-box {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.8em;
            color: #ffff00;
            font-family: monospace;
        }

    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
</head>
<body>
    <div id="ui">
        <div id="fps-box">FPS: 0</div>
        <h3>Shader Masking (The Pro Way)</h3>
        <p><b>WASD:</b> Move & Paint</p>
        <p><b>SHIFT + WASD:</b> Speed Hack</p>
        <div id="score-box">Coverage: 0.0%</div>
        <p style="font-size: 0.8em; color: #aaa">
            <i>Tech: Dynamic Canvas acts as a black/white MASK. The Shader fills the white areas with a tiled "Ink Pattern" texture.</i>
        </p>
        <p style="color: #ff4444" id="status">Status: Synced</p>
    </div>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        window.addEventListener('DOMContentLoaded', function () {
            const canvas = document.getElementById("renderCanvas");
            const engine = new BABYLON.Engine(canvas, true);
            const statusText = document.getElementById("status");
            const scoreText = document.getElementById("score-box");
            const fpsText = document.getElementById("fps-box");

            const createScene = async function () {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.15);

                // --- PHYSICS ---
                const havokInstance = await HavokPhysics();
                const hk = new BABYLON.HavokPlugin(true, havokInstance);
                scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), hk);

                // --- CAMERA & LIGHT ---
                const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 25, BABYLON.Vector3.Zero(), scene);
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
                
                // --- GENERATE ASSETS ---
                
                // 1. FLOOR TEXTURE (Gray Tiles)
                const createFloorTexture = () => {
                    const size = 256;
                    const dt = new BABYLON.DynamicTexture("floor", size, scene, false);
                    const ctx = dt.getContext();
                    ctx.fillStyle = "#444444"; ctx.fillRect(0,0,size,size);
                    ctx.strokeStyle = "#333333"; ctx.lineWidth = 4; ctx.strokeRect(0,0,size,size);
                    dt.update();
                    dt.wrapU = 1; dt.wrapV = 1;
                    return dt;
                };
                const floorTexture = createFloorTexture();

                // 2. INK PATTERN TEXTURE (The "Skin")
                // This is the static image that will appear inside the paint.
                const createInkTexture = () => {
                    const size = 128;
                    const dt = new BABYLON.DynamicTexture("ink", size, scene, false);
                    const ctx = dt.getContext();
                    
                    // Background: Bright Blue
                    ctx.fillStyle = "#0096FF";
                    ctx.fillRect(0,0,size,size);
                    
                    // Detail: Lighter Blue diagonal stripes
                    ctx.fillStyle = "#33adff";
                    ctx.beginPath();
                    ctx.moveTo(0, size); ctx.lineTo(size, 0); ctx.lineTo(size, 20); ctx.lineTo(20, size);
                    ctx.fill();
                    
                    // Detail: Glow dots
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.beginPath(); ctx.arc(32, 32, 10, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(96, 96, 5, 0, Math.PI*2); ctx.fill();

                    dt.update();
                    dt.wrapU = 1; dt.wrapV = 1;
                    return dt;
                };
                const inkTexture = createInkTexture();

                // 3. MASK TEXTURE (The Dynamic Canvas)
                // Black = No Paint, White = Paint.
                const textureResolution = 512;
                const maskTexture = new BABYLON.DynamicTexture("mask", textureResolution, scene, false);
                const maskContext = maskTexture.getContext();
                maskContext.clearRect(0, 0, textureResolution, textureResolution); // Init to transparent (Black in shader terms)
                maskTexture.update();
                maskTexture.hasAlpha = true;

                // 4. BACKING CANVAS (For Server Rollback Logic)
                const backingCanvas = document.createElement("canvas");
                backingCanvas.width = textureResolution;
                backingCanvas.height = textureResolution;
                const backingContext = backingCanvas.getContext("2d");
                backingContext.clearRect(0, 0, textureResolution, textureResolution);

                // --- SHADOW GRID (For Scoring) ---
                // We keep this because it's insanely fast compared to reading pixels
                const shadowGrid = new Uint8Array(textureResolution * textureResolution);
                let totalPaintedPixels = 0;

                // --- CUSTOM SHADER ---
                BABYLON.Effect.ShadersStore["splatVertexShader"] = `
                    precision highp float;
                    attribute vec3 position;
                    attribute vec2 uv;
                    uniform mat4 worldViewProjection;
                    varying vec2 vUV;
                    void main() {
                        gl_Position = worldViewProjection * vec4(position, 1.0);
                        vUV = uv;
                    }
                `;

                BABYLON.Effect.ShadersStore["splatFragmentShader"] = `
                    precision highp float;
                    varying vec2 vUV;
                    
                    uniform sampler2D floorSampler; // The concrete
                    uniform sampler2D inkSampler;   // The pattern (stripes)
                    uniform sampler2D maskSampler;  // The dynamic splats
                    
                    void main() {
                        // 1. Sample Floor (Tile it 10x)
                        vec3 floorColor = texture2D(floorSampler, vUV * 10.0).rgb;
                        
                        // 2. Sample Ink Pattern (Tile it 15x for detail)
                        vec3 inkColor = texture2D(inkSampler, vUV * 15.0).rgb;
                        
                        // 3. Sample Mask (The user's drawing)
                        // We use the alpha channel of the mask to decide mix amount
                        float alpha = texture2D(maskSampler, vUV).a;
                        
                        // 4. Mix
                        vec3 finalColor = mix(floorColor, inkColor, alpha);
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `;

                const shaderMat = new BABYLON.ShaderMaterial("splatShader", scene, {
                    vertex: "splat",
                    fragment: "splat",
                }, {
                    attributes: ["position", "uv"],
                    uniforms: ["worldViewProjection"]
                });
                shaderMat.setTexture("floorSampler", floorTexture);
                shaderMat.setTexture("inkSampler", inkTexture);
                shaderMat.setTexture("maskSampler", maskTexture);

                const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 20, height: 20}, scene);
                ground.material = shaderMat;
                new BABYLON.PhysicsAggregate(ground, BABYLON.PhysicsShapeType.BOX, { mass: 0 }, scene);


                // --- DRAWING LOGIC (Simplified) ---
                // We just draw SOLID WHITE shapes. The shader handles the look.
                const drawSplat = (u, v, seed, ctx, updateGrid = false) => {
                    const x = Math.floor(u * textureResolution);
                    const y = Math.floor((1 - v) * textureResolution);
                    
                    // Always white/opaque for the mask
                    ctx.fillStyle = "rgba(255, 255, 255, 1.0)";
                    
                    const random = () => {
                        seed = (seed * 9301 + 49297) % 233280;
                        return seed / 233280;
                    };

                    const drawCircle = (cx, cy, r) => {
                        ctx.beginPath();
                        ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                        ctx.fill();

                        if (updateGrid) {
                            // Update CPU Grid for scoring
                            const minX = Math.max(0, Math.floor(cx - r));
                            const maxX = Math.min(textureResolution-1, Math.floor(cx + r));
                            const minY = Math.max(0, Math.floor(cy - r));
                            const maxY = Math.min(textureResolution-1, Math.floor(cy + r));
                            const rSq = r * r;
                            for (let py = minY; py <= maxY; py++) {
                                for (let px = minX; px <= maxX; px++) {
                                    const idx = py * textureResolution + px;
                                    if (shadowGrid[idx] === 0) {
                                        const dx = px - cx;
                                        const dy = py - cy;
                                        if (dx*dx + dy*dy <= rSq) {
                                            shadowGrid[idx] = 1;
                                            totalPaintedPixels++;
                                        }
                                    }
                                }
                            }
                        }
                    };

                    // Main Blob
                    drawCircle(x, y, 15 + random() * 10);

                    // Droplets
                    const droplets = 3 + Math.floor(random() * 5);
                    for (let i = 0; i < droplets; i++) {
                        const angle = random() * Math.PI * 2;
                        const dist = 20 + random() * 12;
                        const size = 3 + random() * 5;
                        drawCircle(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist, size);
                    }
                };

                // --- RESET FUNCTIONS ---
                const clearShadowGrid = () => {
                    shadowGrid.fill(0);
                    totalPaintedPixels = 0;
                };

                const rebuildShadowGrid = (historySplats) => {
                    clearShadowGrid();
                    for (let splat of historySplats) {
                         drawSplat(splat.u, splat.v, splat.seed, backingContext, true);
                    }
                    for (let splat of pendingSplats) {
                         drawSplat(splat.u, splat.v, splat.seed, backingContext, true);
                    }
                };

                // --- PLAYER ---
                const player = BABYLON.MeshBuilder.CreateCapsule("player", {radius: 0.5, height: 2}, scene);
                player.position.y = 2;
                const playerMat = new BABYLON.StandardMaterial("playerMat", scene);
                playerMat.diffuseColor = new BABYLON.Color3(0, 0.6, 1); 
                player.material = playerMat;
                const playerAgg = new BABYLON.PhysicsAggregate(player, BABYLON.PhysicsShapeType.CAPSULE, { mass: 1, friction: 0, restitution: 0 }, scene);
                playerAgg.body.setMassProperties({ inertia: new BABYLON.Vector3(0, 0, 0) });

                // --- STATE & NETWORKING ---
                let inFlightSplats = new Map();
                let pendingSplats = [];
                let confirmedSplats = []; 

                const refreshTexture = () => {
                    // Wipe Visible Mask
                    maskContext.clearRect(0, 0, textureResolution, textureResolution);
                    // Copy Truth Mask
                    maskContext.drawImage(backingCanvas, 0, 0);
                    // Draw Pending
                    for (let [id, splats] of inFlightSplats) {
                        for (let splat of splats) drawSplat(splat.u, splat.v, splat.seed, maskContext, false);
                    }
                    for (let splat of pendingSplats) {
                        drawSplat(splat.u, splat.v, splat.seed, maskContext, false);
                    }
                    maskTexture.update();
                };

                // --- MOCK SERVER ---
                const serverState = { position: new BABYLON.Vector3(0, 2, 0), lastUpdate: Date.now(), MAX_SPEED: 14.0 };

                // --- INPUT & LOOP ---
                const inputMap = {};
                scene.actionManager = new BABYLON.ActionManager(scene);
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt) => inputMap[evt.sourceEvent.key.toLowerCase()] = true));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, (evt) => inputMap[evt.sourceEvent.key.toLowerCase()] = false));

                let lastPacketTime = 0;
                const NETWORK_RATE = 100; 

                scene.onBeforeRenderObservable.add(() => {
                    // PREDICTION
                    const isSprinting = inputMap["shift"];
                    const speed = isSprinting ? 25 : 2.5; 
                    const vel = playerAgg.body.getLinearVelocity();
                    let inputDir = new BABYLON.Vector3(0, 0, 0);
                    if (inputMap["w"]) inputDir.z += 1;
                    if (inputMap["s"]) inputDir.z -= 1;
                    if (inputMap["a"]) inputDir.x -= 1;
                    if (inputMap["d"]) inputDir.x += 1;
                    if (inputDir.length() > 0) { inputDir.normalize(); inputDir.scaleInPlace(speed); }
                    playerAgg.body.setLinearVelocity(new BABYLON.Vector3(inputDir.x, vel.y, inputDir.z));

                    // PAINTING
                    if (inputDir.lengthSquared() > 0) {
                        const ray = new BABYLON.Ray(player.position, new BABYLON.Vector3(0, -1, 0), 2.5);
                        const hit = scene.pickWithRay(ray, (mesh) => mesh === ground);
                        if (hit.hit) {
                            const uv = hit.getTextureCoordinates();
                            if (uv) {
                                const seed = Math.random();
                                
                                // Draw to VISIBLE MASK (Optimistic)
                                drawSplat(uv.x, uv.y, seed, maskContext, true); 
                                maskTexture.update();
                                
                                pendingSplats.push({ u: uv.x, v: uv.y, seed: seed });
                            }
                        }
                    }

                    // INSTANT SCORING
                    const percent = (totalPaintedPixels / (textureResolution * textureResolution)) * 100;
                    scoreText.innerText = `Coverage: ${percent.toFixed(1)}%`;

                    // NETWORK
                    const now = Date.now();
                    if (now - lastPacketTime > NETWORK_RATE) {
                        lastPacketTime = now;
                        const packetId = now; 
                        const payload = {
                            id: packetId,
                            pos: player.position.clone(),
                            splats: [...pendingSplats] 
                        };
                        if (pendingSplats.length > 0) {
                            inFlightSplats.set(packetId, [...pendingSplats]);
                            pendingSplats = [];
                        }
                        simulateNetworkRoundTrip(payload);
                    }
                });

                function simulateNetworkRoundTrip(payload) {
                    setTimeout(() => {
                        let serverAccepted = true;
                        const now = Date.now();
                        const timeDelta = (now - serverState.lastUpdate) / 1000;
                        if (timeDelta > 0.01) {
                            const dist = BABYLON.Vector3.Distance(payload.pos, serverState.position);
                            const calculatedSpeed = dist / timeDelta;
                            if (calculatedSpeed > serverState.MAX_SPEED) serverAccepted = false;
                            else { serverState.position = payload.pos; serverState.lastUpdate = now; }
                        }
                        respondToClient(serverAccepted, serverState.position, payload.id);
                    }, 100);
                }

                function respondToClient(accepted, serverTruthPos, packetId) {
                    if (!accepted) {
                        statusText.innerText = "Status: REJECTED (Rollback)";
                        statusText.style.color = "red";
                        playerAgg.body.setLinearVelocity(BABYLON.Vector3.Zero());
                        playerAgg.body.setAngularVelocity(BABYLON.Vector3.Zero());
                        playerAgg.body.disablePreStep = false;
                        player.position.copyFrom(serverTruthPos);
                        player.computeWorldMatrix(true);
                        
                        inFlightSplats.clear();
                        pendingSplats = [];
                        
                        rebuildShadowGrid(confirmedSplats); 
                        refreshTexture(); 
                    } else {
                        statusText.innerText = "Status: Synced";
                        statusText.style.color = "#44ff44";
                        playerAgg.body.disablePreStep = true;
                        
                        if (inFlightSplats.has(packetId)) {
                            const confirmedBatch = inFlightSplats.get(packetId);
                            confirmedSplats.push(...confirmedBatch); 
                            
                            // Commit to Backing MASK
                            for(let splat of confirmedBatch) {
                                drawSplat(splat.u, splat.v, splat.seed, backingContext, false); 
                            }
                            inFlightSplats.delete(packetId);
                        }
                    }
                }

                return scene;
            };

            createScene().then(scene => {
                engine.runRenderLoop(() => {
                    scene.render();
                    fpsText.innerText = engine.getFps().toFixed(0) + " fps";
                });
                window.addEventListener("resize", () => engine.resize());
                canvas.addEventListener("click", () => canvas.focus());
            });
        });
    </script>
</body>
</html>